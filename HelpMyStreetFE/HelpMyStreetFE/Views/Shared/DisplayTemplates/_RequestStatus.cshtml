@using System.Linq;
@using HelpMyStreet.Utils.Enums;
@using HelpMyStreet.Utils.Extensions;
@using HelpMyStreetFE.Helpers;
@using HelpMyStreetFE.Models.Account.Jobs;

@model IEnumerable<KeyValuePair<JobStatuses, int>>;

@{

    JobStatuses? singleStatus = null;
    Dictionary<JobStatuses, int> unCancelledStatuses = null;
    int totalUncancelledJobs = 0;

    int dashOffset = 0;

    List<StatusCircleSegment> segments = new List<StatusCircleSegment>();

    if (Model.All(s => s.Key.Equals(JobStatuses.Cancelled)))
    {
        singleStatus = JobStatuses.Cancelled;
    }
    else
    {
        unCancelledStatuses = Model.Where(s => !s.Key.Equals(JobStatuses.Cancelled)).ToDictionary(a => a.Key, a => a.Value);
        totalUncancelledJobs = unCancelledStatuses.Sum(s => s.Value);

        if (unCancelledStatuses.Count() == 1)
        {
            singleStatus = unCancelledStatuses.First().Key;
        }
        dashOffset = 100 * unCancelledStatuses.Last().Value / @totalUncancelledJobs;

        int offsetJobs = 0;

        foreach (var s in unCancelledStatuses.OrderBy(s => s.Key.UsualOrderOfProgression()))
        {
            segments.Add(new StatusCircleSegment
            {
                Class = s.Key.ToString(),
                Radius = 1.3,
                Proportion = (double)s.Value / totalUncancelledJobs,
                OffsetProportion = (double)offsetJobs / totalUncancelledJobs
            });

            offsetJobs += s.Value;
        }
    }
}


@if (singleStatus != null)
{
    <img class="status-icon" src="~/img/icons/status/@singleStatus.Value.Icon()" alt="@singleStatus.Value.FriendlyName()" />
    <span class="job__status">@singleStatus.Value.FriendlyName()</span>
}
else
{
    <div class="status-circle">

        <svg>
            <filter id="dropshadow" height="130%" width="130%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="3"></feGaussianBlur> <!-- stdDeviation is how much to blur -->
                <feOffset dx="2" dy="2" result="offsetblur"></feOffset> <!-- how much to offset -->
                <feComponentTransfer>
                    <feFuncA type="linear" slope="0.5"></feFuncA> <!-- slope is the opacity of the shadow -->
                </feComponentTransfer>
                <feMerge>
                    <feMergeNode></feMergeNode> <!-- this contains the offset blurred image -->
                    <feMergeNode in="SourceGraphic"></feMergeNode> <!-- this contains the element that the filter is applied to -->
                </feMerge>
            </filter>

            @foreach (var segment in segments)
            {
                <circle class="@segment.Class" cx="50%" cy="50%" r="@segment.R" style="stroke-dashoffset: @segment.DashOffset; stroke-dasharray: @segment.DashArray"></circle>
            }

            @*@if (unCancelledStatuses.ContainsKey(JobStatuses.New))
                {
                    <circle class="new" cx="50%" cy="50%" r="1rem" style="filter: url(#dropshadow); stroke-dashoffset: calc(2rem * 3.141 - @unCancelledStatuses[JobStatuses.New] / @totalUncancelledJobs * 2rem * 3.141)"></circle>
                }
                @if (unCancelledStatuses.ContainsKey(JobStatuses.Open))
                {
                    <circle class="open" cx="50%" cy="50%" r="1rem" style="filter: url(#dropshadow); stroke-dashoffset: calc(2rem * 3.141 - @unCancelledStatuses[JobStatuses.Open] / @totalUncancelledJobs * 2rem * 3.141)"></circle>
                }
                @if (unCancelledStatuses.ContainsKey(JobStatuses.Accepted))
                {
                    <circle class="accepted" cx="50%" cy="50%" r="1rem" style="filter: url(#dropshadow); stroke-dashoffset: calc(2rem * 3.141 - @unCancelledStatuses[JobStatuses.Accepted] / @totalUncancelledJobs * 2rem * 3.141)"></circle>
                }
                @if (unCancelledStatuses.ContainsKey(JobStatuses.InProgress))
                {
                    <circle class="in-progress" cx="50%" cy="50%" r="1rem" style="filter: url(#dropshadow); stroke-dashoffset: calc(2rem * 3.141 - @unCancelledStatuses[JobStatuses.InProgress] / @totalUncancelledJobs * 2rem * 3.141)"></circle>
                }
                @if (unCancelledStatuses.ContainsKey(JobStatuses.Done))
                {
                    <circle class="complete" cx="50%" cy="50%" r="1rem" style="filter: url(#dropshadow); stroke-dashoffset: calc(2rem * 3.141 - @unCancelledStatuses[JobStatuses.Done] / @totalUncancelledJobs * 2rem * 3.141)"></circle>
                }*@

            @*<circle class="backBar" cx="50%" cy="50%" r="1rem" style="filter: url(#dropshadow);"><title>shifts not yet filled</title></circle>
                <circle class="jobBar" cx="50%" cy="50%" r="1rem" stroke-dashoffset="@dashOffset%">
                    <title>shifts filled</title>

                </circle>*@
            <path class="tick" fill="none" stroke="white" stroke-width="3" d="M12 27.2l7.1 7 16.7-16.8" />

        </svg>
    </div>
    <span class="job__status">
        @foreach (var a in unCancelledStatuses)
        {
            @($"{a.Value} {a.Key.FriendlyName()}")<br />
        }
    </span>
}